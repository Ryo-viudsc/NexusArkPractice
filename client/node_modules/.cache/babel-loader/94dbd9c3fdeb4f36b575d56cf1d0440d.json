{"ast":null,"code":"//by using this,\n//we can optimize the perfomance \n//especially for the value of state \n//For example, in this project \n//when an user logs-in, \n//the redux is fired off and \n//the whole tree state is updated and \n//react re-renders the currentUser component \n//In the mean time, \n//(looking at the cart-icon.component file)\n//const mapStateToProps = ({cart : {cartItems}}) => ({\n//   itemCount : cartItems.reduce((accumalatedQuantity, cartItem )=> accumalatedQuantity + cartItem.quantity, 0) \n// })\n//this entire function \"cartItems.reduce(....)\" also gets fired off\n//just because the state is updated and react renders other components somewhere\n//and  this is not good for performance \n//It's because, everytime a part of state somewhere is updated, \n//the entire part of \"cartItems.reduce(....) will be \n//calculated again, meaning it takes a liner time\n//the following library is for this issue specifically \n//and memoizes a slice of state and cache a result of some calculation\nimport { createSelector } from 'reselect';\n\nconst selectCart = state => state.cart;\n\nexport const selectCartItems = createSelector([selectCart], cart => cart.cartItems);\nexport const selectCartHidden = createSelector([selectCart], cart => cart.hidden);\nexport const selectCartItemsCount = createSelector([selectCartItems, selectCartHidden], cartItems => cartItems.reduce((accumalatedQuantity, cartItem) => accumalatedQuantity + cartItem.quantity, 0));","map":{"version":3,"sources":["C:/Users/bskki/AWSamp_GraphQL Udemy/crwn-clothing/src/redux/cart/cart.selectors.js"],"names":["createSelector","selectCart","state","cart","selectCartItems","cartItems","selectCartHidden","hidden","selectCartItemsCount","reduce","accumalatedQuantity","cartItem","quantity"],"mappings":"AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA,SAASA,cAAT,QAA+B,UAA/B;;AAEA,MAAMC,UAAU,GAAGC,KAAK,IAAIA,KAAK,CAACC,IAAlC;;AAEA,OAAO,MAAMC,eAAe,GAAGJ,cAAc,CAC3C,CAACC,UAAD,CAD2C,EAE3CE,IAAI,IAAIA,IAAI,CAACE,SAF8B,CAAtC;AAKP,OAAO,MAAMC,gBAAgB,GAAGN,cAAc,CAC5C,CAACC,UAAD,CAD4C,EAE5CE,IAAI,IAAIA,IAAI,CAACI,MAF+B,CAAvC;AAMP,OAAO,MAAMC,oBAAoB,GAAGR,cAAc,CAChD,CAACI,eAAD,EAAkBE,gBAAlB,CADgD,EAEhDD,SAAS,IACRA,SAAS,CAACI,MAAV,CACC,CAACC,mBAAD,EAAsBC,QAAtB,KAAmCD,mBAAmB,GAAGC,QAAQ,CAACC,QADnE,EAC6E,CAD7E,CAH+C,CAA3C","sourcesContent":["//by using this,\r\n//we can optimize the perfomance \r\n//especially for the value of state \r\n\r\n//For example, in this project \r\n//when an user logs-in, \r\n//the redux is fired off and \r\n//the whole tree state is updated and \r\n//react re-renders the currentUser component \r\n\r\n//In the mean time, \r\n//(looking at the cart-icon.component file)\r\n//const mapStateToProps = ({cart : {cartItems}}) => ({\r\n//   itemCount : cartItems.reduce((accumalatedQuantity, cartItem )=> accumalatedQuantity + cartItem.quantity, 0) \r\n// })\r\n//this entire function \"cartItems.reduce(....)\" also gets fired off\r\n//just because the state is updated and react renders other components somewhere\r\n//and  this is not good for performance \r\n//It's because, everytime a part of state somewhere is updated, \r\n//the entire part of \"cartItems.reduce(....) will be \r\n//calculated again, meaning it takes a liner time\r\n\r\n//the following library is for this issue specifically \r\n//and memoizes a slice of state and cache a result of some calculation\r\nimport { createSelector } from 'reselect';\r\n\r\nconst selectCart = state => state.cart;\r\n\r\nexport const selectCartItems = createSelector(\r\n  [selectCart],\r\n  cart => cart.cartItems \r\n)\r\n\r\nexport const selectCartHidden = createSelector(\r\n  [selectCart],\r\n  cart => cart.hidden\r\n)\r\n\r\n\r\nexport const selectCartItemsCount = createSelector(\r\n  [selectCartItems, selectCartHidden],\r\n  cartItems => \r\n   cartItems.reduce(\r\n    (accumalatedQuantity, cartItem )=> accumalatedQuantity + cartItem.quantity, 0)\r\n)"]},"metadata":{},"sourceType":"module"}