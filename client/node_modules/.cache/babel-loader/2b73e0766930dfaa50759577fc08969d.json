{"ast":null,"code":"// Selectors can compute derived data, allowing Redux to store the minimal possible state.\n// Selectors are efficient. A selector is not recomputed unless one of its arguments changes.\n//by using this,\n//we can optimize the perfomance \n//especially for the value of state \n//For example, in this project \n//when an user logs-in, \n//the redux is fired off and \n//the whole tree state is updated and \n//react re-renders the currentUser component \n//In the mean time, \n//(looking at the cart-icon.component file)\n//const mapStateToProps = ({cart : {cartItems}}) => ({\n//   itemCount : cartItems.reduce((accumalatedQuantity, cartItem )=> accumalatedQuantity + cartItem.quantity, 0) \n// })\n//this entire function \"cartItems.reduce(....)\" also gets fired off\n//just because the state is updated and react renders other components somewhere\n//and  this is not good for performance \n//It's because, everytime a part of state somewhere is updated, \n//the entire part of \"cartItems.reduce(....) will be \n//calculated again, meaning it takes a liner time\n//the following library is for this issue specifically \n//and memoizes a slice of state and cache a result of some calculation\nimport{createSelector}from'reselect';var selectCart=function selectCart(state){return state.cart;};export var selectCartItems=createSelector([selectCart],function(cart){return cart.cartItems;});//this is a litlle different from the selector above \n//since we don't need the complicated calculation\nexport var selectCartHidden=createSelector([selectCart],function(cart){return cart.hidden;});export var selectHovered=createSelector([selectCart],function(cart){return cart.hovered;});export var selectCartItemsCount=createSelector([selectCartItems,selectCartHidden],function(cartItems){return cartItems.reduce(function(accumalatedQuantity,cartItem){return accumalatedQuantity+cartItem.quantity;},0);});export var selectCartTotal=createSelector([selectCartItems],function(cartItems){return cartItems.reduce(function(accumalatedTotal,cartItem){return accumalatedTotal+cartItem.quantity*cartItem.price;},0);});","map":{"version":3,"sources":["C:/Users/bskki/AWSamp_GraphQL Udemy/crwn-clothing/client/src/redux/cart/cart.selectors.js"],"names":["createSelector","selectCart","state","cart","selectCartItems","cartItems","selectCartHidden","hidden","selectHovered","hovered","selectCartItemsCount","reduce","accumalatedQuantity","cartItem","quantity","selectCartTotal","accumalatedTotal","price"],"mappings":"AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA,OAASA,cAAT,KAA+B,UAA/B,CAEA,GAAMC,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CAAAC,KAAK,QAAIA,CAAAA,KAAK,CAACC,IAAV,EAAxB,CAEA,MAAO,IAAMC,CAAAA,eAAe,CAAGJ,cAAc,CAC3C,CAACC,UAAD,CAD2C,CAE3C,SAAAE,IAAI,QAAIA,CAAAA,IAAI,CAACE,SAAT,EAFuC,CAAtC,CAKP;AACA;AACA,MAAO,IAAMC,CAAAA,gBAAgB,CAAGN,cAAc,CAC5C,CAACC,UAAD,CAD4C,CAE5C,SAAAE,IAAI,QAAIA,CAAAA,IAAI,CAACI,MAAT,EAFwC,CAAvC,CAKP,MAAO,IAAMC,CAAAA,aAAa,CAAGR,cAAc,CACzC,CAACC,UAAD,CADyC,CAEzC,SAAAE,IAAI,QAAIA,CAAAA,IAAI,CAACM,OAAT,EAFqC,CAApC,CAQP,MAAO,IAAMC,CAAAA,oBAAoB,CAAGV,cAAc,CAChD,CAACI,eAAD,CAAkBE,gBAAlB,CADgD,CAEhD,SAAAD,SAAS,QACRA,CAAAA,SAAS,CAACM,MAAV,CACC,SAACC,mBAAD,CAAsBC,QAAtB,QAAmCD,CAAAA,mBAAmB,CAAGC,QAAQ,CAACC,QAAlE,EADD,CAC6E,CAD7E,CADQ,EAFuC,CAA3C,CAQP,MAAO,IAAMC,CAAAA,eAAe,CAAGf,cAAc,CAC3C,CAACI,eAAD,CAD2C,CAE3C,SAAAC,SAAS,QACPA,CAAAA,SAAS,CAACM,MAAV,CACE,SAACK,gBAAD,CAAmBH,QAAnB,QAAgCG,CAAAA,gBAAgB,CAAIH,QAAQ,CAACC,QAAT,CAAoBD,QAAQ,CAACI,KAAjF,EADF,CAC0F,CAD1F,CADO,EAFkC,CAAtC","sourcesContent":["// Selectors can compute derived data, allowing Redux to store the minimal possible state.\r\n// Selectors are efficient. A selector is not recomputed unless one of its arguments changes.\r\n\r\n//by using this,\r\n//we can optimize the perfomance \r\n//especially for the value of state \r\n\r\n//For example, in this project \r\n//when an user logs-in, \r\n//the redux is fired off and \r\n//the whole tree state is updated and \r\n//react re-renders the currentUser component \r\n\r\n//In the mean time, \r\n//(looking at the cart-icon.component file)\r\n//const mapStateToProps = ({cart : {cartItems}}) => ({\r\n//   itemCount : cartItems.reduce((accumalatedQuantity, cartItem )=> accumalatedQuantity + cartItem.quantity, 0) \r\n// })\r\n//this entire function \"cartItems.reduce(....)\" also gets fired off\r\n//just because the state is updated and react renders other components somewhere\r\n//and  this is not good for performance \r\n//It's because, everytime a part of state somewhere is updated, \r\n//the entire part of \"cartItems.reduce(....) will be \r\n//calculated again, meaning it takes a liner time\r\n\r\n//the following library is for this issue specifically \r\n//and memoizes a slice of state and cache a result of some calculation\r\nimport { createSelector } from 'reselect';\r\n\r\nconst selectCart = state => state.cart;\r\n\r\nexport const selectCartItems = createSelector(\r\n  [selectCart],\r\n  cart => cart.cartItems \r\n)\r\n\r\n//this is a litlle different from the selector above \r\n//since we don't need the complicated calculation\r\nexport const selectCartHidden = createSelector(\r\n  [selectCart],\r\n  cart => cart.hidden\r\n)\r\n\r\nexport const selectHovered = createSelector(\r\n  [selectCart],\r\n  cart => cart.hovered\r\n)\r\n\r\n\r\n\r\n\r\nexport const selectCartItemsCount = createSelector(\r\n  [selectCartItems, selectCartHidden],\r\n  cartItems => \r\n   cartItems.reduce(\r\n    (accumalatedQuantity, cartItem )=> accumalatedQuantity + cartItem.quantity, 0)\r\n)\r\n\r\n\r\nexport const selectCartTotal = createSelector(\r\n  [selectCartItems],\r\n  cartItems => \r\n    cartItems.reduce(\r\n      (accumalatedTotal, cartItem) => accumalatedTotal +  cartItem.quantity * cartItem.price, 0)\r\n)\r\n"]},"metadata":{},"sourceType":"module"}