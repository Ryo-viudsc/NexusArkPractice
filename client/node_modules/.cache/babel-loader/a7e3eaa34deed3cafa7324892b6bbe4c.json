{"ast":null,"code":"// Selectors can compute derived data, allowing Redux to store the minimal possible state.\n// Selectors are efficient. A selector is not recomputed unless one of its arguments changes.\n//by using this,\n//we can optimize the perfomance \n//especially for the value of state \n//For example, in this project \n//when an user logs-in, \n//the redux is fired off and \n//the whole tree state is updated and \n//react re-renders the currentUser component \n//In the mean time, \n//(looking at the cart-icon.component file)\n//const mapStateToProps = ({cart : {cartItems}}) => ({\n//   itemCount : cartItems.reduce((accumalatedQuantity, cartItem )=> accumalatedQuantity + cartItem.quantity, 0) \n// })\n//this entire function \"cartItems.reduce(....)\" also gets fired off\n//just because the state is updated and react renders other components somewhere\n//and  this is not good for performance \n//It's because, everytime a part of state somewhere is updated, \n//the entire part of \"cartItems.reduce(....) will be \n//calculated again, meaning it takes a liner time\n//the following library is for this issue specifically \n//and memoizes a slice of state and cache a result of some calculation\nimport { createSelector } from 'reselect';\n\nconst selectCart = state => state.cart;\n\nexport const selectCartItems = createSelector([selectCart], cart => cart.cartItems); //this is a litlle different from the selector above \n//since we don't need the complicated calculation\n\nexport const selectCartHidden = createSelector([selectCart], cart => cart.hidden);\nexport const selectCartHover = createSelector([selectCart], cart => cart.hovered);\nexport const selectCartItemsCount = createSelector([selectCartItems, selectCartHidden], cartItems => cartItems.reduce((accumalatedQuantity, cartItem) => accumalatedQuantity + cartItem.quantity, 0));\nexport const selectCartTotal = createSelector([selectCartItems], cartItems => cartItems.reduce((accumalatedTotal, cartItem) => accumalatedTotal + cartItem.quantity * cartItem.price, 0));","map":{"version":3,"sources":["C:/Users/bskki/AWSamp_GraphQL Udemy/crwn-clothing/src/redux/cart/cart.selectors.js"],"names":["createSelector","selectCart","state","cart","selectCartItems","cartItems","selectCartHidden","hidden","selectCartHover","hovered","selectCartItemsCount","reduce","accumalatedQuantity","cartItem","quantity","selectCartTotal","accumalatedTotal","price"],"mappings":"AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA,SAASA,cAAT,QAA+B,UAA/B;;AAEA,MAAMC,UAAU,GAAGC,KAAK,IAAIA,KAAK,CAACC,IAAlC;;AAEA,OAAO,MAAMC,eAAe,GAAGJ,cAAc,CAC3C,CAACC,UAAD,CAD2C,EAE3CE,IAAI,IAAIA,IAAI,CAACE,SAF8B,CAAtC,C,CAKP;AACA;;AACA,OAAO,MAAMC,gBAAgB,GAAGN,cAAc,CAC5C,CAACC,UAAD,CAD4C,EAE5CE,IAAI,IAAIA,IAAI,CAACI,MAF+B,CAAvC;AAKP,OAAO,MAAMC,eAAe,GAAGR,cAAc,CAC3C,CAACC,UAAD,CAD2C,EAE3CE,IAAI,IAAIA,IAAI,CAACM,OAF8B,CAAtC;AAOP,OAAO,MAAMC,oBAAoB,GAAGV,cAAc,CAChD,CAACI,eAAD,EAAkBE,gBAAlB,CADgD,EAEhDD,SAAS,IACRA,SAAS,CAACM,MAAV,CACC,CAACC,mBAAD,EAAsBC,QAAtB,KAAmCD,mBAAmB,GAAGC,QAAQ,CAACC,QADnE,EAC6E,CAD7E,CAH+C,CAA3C;AAQP,OAAO,MAAMC,eAAe,GAAGf,cAAc,CAC3C,CAACI,eAAD,CAD2C,EAE3CC,SAAS,IACPA,SAAS,CAACM,MAAV,CACE,CAACK,gBAAD,EAAmBH,QAAnB,KAAgCG,gBAAgB,GAAIH,QAAQ,CAACC,QAAT,GAAoBD,QAAQ,CAACI,KADnF,EAC0F,CAD1F,CAHyC,CAAtC","sourcesContent":["// Selectors can compute derived data, allowing Redux to store the minimal possible state.\r\n// Selectors are efficient. A selector is not recomputed unless one of its arguments changes.\r\n\r\n//by using this,\r\n//we can optimize the perfomance \r\n//especially for the value of state \r\n\r\n//For example, in this project \r\n//when an user logs-in, \r\n//the redux is fired off and \r\n//the whole tree state is updated and \r\n//react re-renders the currentUser component \r\n\r\n//In the mean time, \r\n//(looking at the cart-icon.component file)\r\n//const mapStateToProps = ({cart : {cartItems}}) => ({\r\n//   itemCount : cartItems.reduce((accumalatedQuantity, cartItem )=> accumalatedQuantity + cartItem.quantity, 0) \r\n// })\r\n//this entire function \"cartItems.reduce(....)\" also gets fired off\r\n//just because the state is updated and react renders other components somewhere\r\n//and  this is not good for performance \r\n//It's because, everytime a part of state somewhere is updated, \r\n//the entire part of \"cartItems.reduce(....) will be \r\n//calculated again, meaning it takes a liner time\r\n\r\n//the following library is for this issue specifically \r\n//and memoizes a slice of state and cache a result of some calculation\r\nimport { createSelector } from 'reselect';\r\n\r\nconst selectCart = state => state.cart;\r\n\r\nexport const selectCartItems = createSelector(\r\n  [selectCart],\r\n  cart => cart.cartItems \r\n)\r\n\r\n//this is a litlle different from the selector above \r\n//since we don't need the complicated calculation\r\nexport const selectCartHidden = createSelector(\r\n  [selectCart],\r\n  cart => cart.hidden\r\n)\r\n\r\nexport const selectCartHover = createSelector(\r\n  [selectCart],\r\n  cart => cart.hovered\r\n)\r\n\r\n\r\n\r\nexport const selectCartItemsCount = createSelector(\r\n  [selectCartItems, selectCartHidden],\r\n  cartItems => \r\n   cartItems.reduce(\r\n    (accumalatedQuantity, cartItem )=> accumalatedQuantity + cartItem.quantity, 0)\r\n)\r\n\r\n\r\nexport const selectCartTotal = createSelector(\r\n  [selectCartItems],\r\n  cartItems => \r\n    cartItems.reduce(\r\n      (accumalatedTotal, cartItem) => accumalatedTotal +  cartItem.quantity * cartItem.price, 0)\r\n)\r\n"]},"metadata":{},"sourceType":"module"}